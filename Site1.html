<p>Fn Tutorial</p>
<p>Fn is a simple web framework build in Haskell.</p>
<p>This tutorial will show you how to make a very simple website with Fn.</p>
<h2 id="the-simplest-site">The Simplest Site</h2>
<p>stack build stack exec site1</p>
<p>visit localhost:3000</p>
<p>How does it work?!</p>
<p>well --- this is the source!! This page is written in &quot;Literate Haskell&quot;, so you can run it as source code. I'll take you line by line and show you what's going on.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></code></pre></div>
<p>Haskell is a pretty small language without a lot of baked-in features. You can add extra features by including&quot;pragmas&quot; like this to beginning of the file. &quot;OverloadedStrings&quot; makes working with text a lot easier than it is in plain Haskell.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Web.Fn</span>
<span class="kw">import </span><span class="dt">Network.Wai</span> (<span class="dt">Response</span>, <span class="dt">Application</span>)
<span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span> (run)</code></pre></div>
<p>These import the libraries we'll need for the website: Fn, WAI (Web Application Interface), and Warp. In Haskell, you can import modules from libraries with <code>import</code> + the module name. Then you can optionally restrict the imports to just certain types or functions (as in the second and third lines).</p>
<p>We're going to use Fn as the framework, Warp for the server, and Wai for middleware (like it sounds, stuff in the middle between the framework and server).</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Context</span> <span class="fu">=</span> <span class="dt">Context</span> {<span class="ot"> req ::</span> <span class="dt">FnRequest</span> }</code></pre></div>
<p>Next we're making the context for our application. The idea is that there's data we want to access when we're preparing a Response to send out to a user. It might be in a database, a cache, environment variables, wherever! In Fn, we wrap all those things up in a &quot;Context&quot;. Here, the only information our Context has is about the Request (we'll add other stuff in a later site).</p>
<p>Language/syntax note: This is called a data type. Data types in Haskell are basically the coolest thing ever and you should read more about them (here). But just bookmark that for later, because it's enough to know that this is making a type called Context that has a constructor ALSO called Context, with a field that has the type FnRequest. <code>req</code> is a function that takes a Context and returns an FnRequest.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">RequestContext</span> <span class="dt">Context</span> <span class="kw">where</span>
 getRequest ctxt <span class="fu">=</span> req ctxt
 setRequest ctxt newRequest <span class="fu">=</span> ctxt { req <span class="fu">=</span> newRequest }</code></pre></div>
<p>These lines spell out for Fn how to get the request from the Context we made earlier.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">site ::</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Response</span>
site ctxt <span class="fu">=</span> route ctxt [ end <span class="fu">==&gt;</span> indexHandler ]
                 <span class="ot">`fallthrough`</span> notFoundText <span class="st">&quot;Page not found.&quot;</span></code></pre></div>
<p>Our &quot;site&quot; is a way to take our Context, and turn it into a Response. Don't worry too much about it right now because I'll go into much more depth in the next part on routes!</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">indexHandler ::</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Response</span>)
indexHandler ctxt <span class="fu">=</span> okText <span class="st">&quot;Welcome to my first Haskell website.&quot;</span></code></pre></div>
<p>Hey, it's our first Handler! This handles a request by taking a context and giving back a response (again, we'll go into more detail on just what that <code>IO (Maybe Response)</code> there means in the next part). In this case, we're going to do the same thing every time someone requests this page -- just print a text message.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> run <span class="dv">3000</span> waiApp

<span class="ot">waiApp ::</span> <span class="dt">Application</span>
waiApp <span class="fu">=</span> toWAI (<span class="dt">Context</span> defaultFnRequest) site</code></pre></div>
<p>I said earlier that WAI is the middleware between our site and the server. This is where we use WAI. Warp expects an app, so we use Fn's &quot;toWAI&quot; function to turn an initial context and our <code>site</code> into an Application. <code>run 3000 waiApp</code> means to run the Warp server with this app on port 3000.</p>
<p>Okay, so this site wasn't very exciting... let's learn more about routing and handlers!</p>
